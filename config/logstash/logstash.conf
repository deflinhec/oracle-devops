input {
  beats {
    port => 5044
  }

  tcp {
    port => 5010
    codec => json_lines
  }
}

filter {
  # Docker container logs (from Filebeat container input + add_docker_metadata)
  if [fields][log_source] == "docker" or [container][id] {
    # Docker json-file driver: each line can be {"log":"...","stream":"stdout|stderr","attrs":{...}}
    if [message] =~ /^\s*\{\s*"log"/ {
      json {
        source => "message"
        target => "docker_log"
      }
      if [docker_log][log] {
        mutate { replace => { "message" => "%{[docker_log][log]}" } }
      }
      if [docker_log][stream] {
        mutate { add_field => { "log_level" => "info" } }
        if [docker_log][stream] == "stderr" {
          mutate { update => { "log_level" => "error" } }
        }
      }
      mutate { remove_field => ["docker_log"] }
    } else if [stream] {
      if [stream] == "stdout" {
        mutate { add_field => { "log_level" => "info" } }
      } else if [stream] == "stderr" {
        mutate { add_field => { "log_level" => "error" } }
      }
    }
    # Service from Filebeat processors, or fallback: derive short name from container name (oracle_svc.0.xxx -> svc)
    if ![fields][service] and [container][name] {
      mutate { add_field => { "[fields][service]" => "%{[container][name]}" } }
    }
    # Normalize service when still long form (oracle_svc.0.xxx -> svc)
    if [fields][service] =~ /^oracle_([^.]+)\./ {
      ruby {
        code => 'n = event.get("[fields][service]"); m = n && n.to_s.match(/^oracle_([^.]+)\./); event.set("[fields][service]", m[1]) if m'
      }
    }
  }

  # Nginx container: normalize @timestamp from access JSON; tag error log level for stderr
  if [fields][service] == "nginx" {
    if [log_type] == "nginx_error" {
      mutate { add_field => { "log_level" => "error" } }
    } else if [@timestamp] {
      date {
        match => [ "@timestamp", "ISO8601" ]
        target => "@timestamp"
      }
    }
  }

  # Oracle application logs (ecszap ECS JSON) â€” filestream + container (api, consumer, scheduler)
  if [fields][service] =~ /^oracle-(app|server|scheduler|consumer|api)$/ {
    if [message] =~ /^\{.*\}$/ {
      json {
        source => "message"
      }
    }

    # ECS: use @timestamp from ecszap (ISO8601); fallback for legacy "timestamp" field
    if [@timestamp] {
      date {
        match => [ "@timestamp", "ISO8601" ]
        target => "@timestamp"
      }
    } else if [timestamp] {
      date {
        match => [ "timestamp", "ISO8601" ]
        target => "@timestamp"
      }
    }

    # ECS: ecszap uses log.level (nested [log][level] or flat [log.level]); fallback to legacy "level"
    if [log][level] {
      mutate { add_field => { "log_level" => "%{[log][level]}" } }
    } else if [log.level] {
      mutate { add_field => { "log_level" => "%{[log.level]}" } }
    } else if [level] {
      mutate { add_field => { "log_level" => "%{level}" } }
    }
  }

  mutate {
    add_field => { "cluster" => "default" }
    add_field => { "datacenter" => "local" }
    add_field => { "environment" => "development" }
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "logs-%{+YYYY.MM.dd}"
    template_name => "logs"
    template_overwrite => true
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}
